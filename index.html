<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Manual Zoom Viewer</title>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    height: 100vh;
    overflow: hidden;
  }
  #container {
    position: relative;
    width: 600px;
    height: 600px;
    overflow: hidden;
    border: 1px solid #333;
  }
  img {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    transform-origin: center center;
    transition: transform 0.1s linear, opacity 0.3s ease;
  }
  .hidden { opacity: 0; pointer-events: none; }
  #outline {
    position: absolute;
    border: 2px solid;
    box-shadow: 0 0 6px;
    transform-origin: center center;
    pointer-events: none;
    transition: transform 0.1s linear, border-color 0.3s ease, box-shadow 0.3s ease;
  }
  #caption {
    margin-top: 10px;
    text-align: center;
    width: 600px;
  }
</style>
</head>
<body>

<div id="container">
  <div id="outline"></div>
  <!-- Images will be inserted here by JavaScript -->
</div>
<div id="caption">Description for Image 1</div>
<p style="opacity:0.6;">⬆ Zoom In &nbsp;&nbsp; ⬇ Zoom Out</p>

<script src="config.js"></script>
<script>
// Create image elements from config
const container = document.getElementById('container');
CONFIG.images.forEach((imgConfig, index) => {
    const img = document.createElement('img');
    img.id = imgConfig.id;
    img.src = imgConfig.src;
    img.alt = '';
    if (index > 0) img.classList.add('hidden');
    container.insertBefore(img, document.getElementById('outline'));
});

const images = CONFIG.images;

let current = 0;
let scale = 1;
const zoomStep = 0.05;
const minScale = 1;
const maxScale = 2;

const outline = document.getElementById('outline');
const caption = document.getElementById('caption');

function pixelToRelative(pixelRect, img) {
  if (!pixelRect) return null;
  const [x, y, w, h] = pixelRect;
  // Use the actual image dimensions
  return [
    x / img.naturalWidth,
    y / img.naturalHeight,
    w / img.naturalWidth,
    h / img.naturalHeight
  ];
}

function getRect(imageConfig) {
  // Prefer pixel coordinates if provided, otherwise use relative coordinates
  if (imageConfig.nextPixelRect) {
    const img = document.getElementById(imageConfig.id);
    // Wait for image to load before converting coordinates
    if (img.complete) {
      return pixelToRelative(imageConfig.nextPixelRect, img);
    }
    // If image isn't loaded yet, return null and update later
    img.addEventListener('load', () => {
      // Update outline once image loads
      if (current === images.indexOf(imageConfig)) {
        setOutline(getRect(imageConfig), imageConfig.outlineColor);
      }
    }, { once: true });
    return null;
  }
  return imageConfig.nextRect;
}

function setOutline(rect, outlineColor) {
  if (!rect) { outline.style.display = 'none'; return; }
  outline.style.display = 'block';
  outline.style.left = (rect[0]*100) + '%';
  outline.style.top = (rect[1]*100) + '%';
  outline.style.width = (rect[2]*100) + '%';
  outline.style.height = (rect[3]*100) + '%';
  
  const color = outlineColor || CONFIG.defaultOutlineColor;
  outline.style.borderColor = color;
  outline.style.boxShadow = `0 0 6px ${color}`;
}

function updateZoom() {
  const img = document.getElementById(images[current].id);

  const rect = getRect(images[current]);
  if (rect) {
    // rect = [x, y, w, h] in fractions of image size
    const cx = rect[0] + rect[2] / 2;
    const cy = rect[1] + rect[3] / 2;
    img.style.transformOrigin = `${cx * 100}% ${cy * 100}%`;
    outline.style.transformOrigin = `${cx * 100}% ${cy * 100}%`;
  } else {
    img.style.transformOrigin = "center center";
    outline.style.transformOrigin = "center center";
  }

  img.style.transform = `scale(${scale})`;
  outline.style.transform = `scale(${scale})`;
}


function swapImage(forward) {
  const oldImg = document.getElementById(images[current].id);
  oldImg.classList.add('hidden');

  current += forward ? 1 : -1;
  if (current < 0) current = 0;
  if (current >= images.length) current = images.length - 1;

  const newImg = document.getElementById(images[current].id);
  newImg.classList.remove('hidden');
  caption.textContent = images[current].caption;
  setOutline(getRect(images[current]), images[current].outlineColor);

  // Continuous zoom handling
  if (forward) {
    // When zooming in, start new image at normal scale
    scale = 1;
  } else {
    // When zooming out, start previous image at max zoom so it feels continuous
    scale = maxScale;
  }

  updateZoom();
}


// Keyboard controls
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowUp') {
    scale += zoomStep;
    if (scale >= maxScale) {
      scale = maxScale;
      if (current < images.length - 1) swapImage(true);
    }
    updateZoom();
  }
  if (e.key === 'ArrowDown') {
    scale -= zoomStep;
    if (scale <= minScale) {
	  scale = minScale
      if (current > 0) swapImage(false);
    }
    updateZoom();
  }
});

setOutline(getRect(images[0]), images[0].outlineColor);
updateZoom();
</script>

</body>
</html>
